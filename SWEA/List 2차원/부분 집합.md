# 부분 집합

### 부분 집합의 수

집합의 원소가 n개일 때, 공집합을 포함한 부분 집합의 수는 2ⁿ개

<= 각 원소를 부분 집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같음



### 부분 집합 문제

> 문제
>
> 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분 집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제 

##### 풀이

완전 검색기법으로 부분 집합 합 문제를 풀기 위해서는 우선 집합의 모든 부분 집합을 생성한 후에 각 부분 집합의 합을 계산 함



### 부분 집합 문제 알고리즘 1

```python
# Loop를 이용하여 확인하고, 부분 집합을 생성하는 방법

bit = [0, 0, 0, 0]
for i in range(2):
  bit[0] = i
  for j in range(2):
    bit[1] = j
    for k in range(2):
      bit[2] = k
      for l in range(2):
        bit[3] = l
        print(bit) # 생성된 부분집합 출력
        
# 비트 List: 대상 List의 각 원소를 포함할지 말지를 정하는 List
```



### 부분 집합 문제 알고리즘 2

- 비트 연산자: 0과 1로 이루어진 이진수에 대한 연산을 수행하는 연산자

  |             &             |            \|            |                   <<                   |                    >>                    |
  | :-----------------------: | :----------------------: | :------------------------------------: | :--------------------------------------: |
  |        and(논리곱)        |        or(논리합)        |               left shift               |               right shift                |
  | 비트 단위로 AND 연산을 함 | 비트 단위로 OR 연산을 함 | 피연산자의 비트 열을 왼쪽으로 이동시킴 | 피연산자의 비트 열을 오른쪽으로 이동시킴 |

- >  n<<m: n * 2ᵐ
  >
  > 1<<n: 2ⁿ   => 원소가 n개일 경우의 모든 부분 집합의 수를 의미함

  > i & (1<<j)   => i에서 j번째 비트가 1인지 아닌지를 리턴함

```python
arr = [3, 6, 7 ,1, 5, 4]
n = len(arr) # n: 원소의 개수

for i in range(1<<n): # 1<<n: 부분 집합의 개수
  for j in rnage(n): # 원소의 수만큼 비트를 비교함
    if i & (1<<j): # i의 j번째 비트가 1이면 j번째 원소 출력
      print(arr[j], end=",")
  print()
```



