# Exhaustive Search

- 완전 검색(Exhaustive Search)

  > 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법

  1. Brute-force 혹은 Generate-and-Test 기법이라고도 불림

  2. 모든 경우의 수를 테스트한 후, 최종 해법을 도출함

  3. 일반적으로 경우의 수가 상대적으로 적을 때 유용함

  4. 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작음

  5. 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직함

     

- Baby-gin Game

  - 완전 검색(Exhaustive Search)

    1. 고려할 수 있는 모든 경우의 수 생성하기

       > 6개의 숫자로 만들 수 있는 모든 숫자 나열(중복 포함)
       >
       > e.g.) 입력: {2, 3, 5, 7, 7, 7}
       >
       > 2 3 5 7 7 7
       >
       > 2 3 7 5 7 7
       >
       > 2 3 7 7 5 7
       >
       > ...
       >
       > 7 7 7 5 3 2
       >
       > 모든 경우의 순열 나열 

    2. 해답 테스트하기

       > 앞의 3자리와 뒤의 3자리를 잘라, run와 triplete 여부를 테스트하고 최종적으로 Baby-gin을 판단함
       >
       > e.g.)
       >
       > 2 3 5 (-> 해당없음) 7 7 7 (->triplete)
       >
       > => Baby-gin 아님

  - 순열(Permutation): 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것

    1. 서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현

       > nPr

    2. nPr은 다음과 같은 식이 성립함

       > nPr = n * (n-1) * (n-2) * ... * 2 * 1

    3. nPn = n!이라고 표기하며 Factorial이라 부름

       > n! = n * (n-1) * (n-2) * ... * 2 * 1

    > e.g.) {1, 2, 3}을 포함하는 모든 순열을 생서하는 함수
    >
    > 동일한 숫자가 포함되지 않았을 때, 각 자릿수 별로 loop을 이용함
    >
    > ```python
    > for i1 in range(1, 4):
    >   for i2 in range(1, 4):
    >     if i2 != i1:
    >       for i3 in range(1, 4):
    >         if i3 != i1 and i3 != i2:
    >           print(i1, i2, i3)
    > ```
    >
    > 

  

