# Sort

### 정렬 개요

- 정렬(Sort)이란?

  > 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순: ascending), 혹은 그 반대의 순서대로(내림차순: descending) 재배열하는 것

- 대표적인 정렬 방식의 종류

  > - 버블 정렬(Bubble Sort)
  > - 카운팅 정렬(Counting Sort)
  > - 선택 정렬(Selection Sort)
  > - 퀵 정렬(Quick Sort)
  > - 삽입 정렬(Insertion Sort)
  > - 병합 정렬(Merge Sort)

  |  알고리즘   | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 |                      비고                       |
  | :---------: | :-----------: | :-----------: | :-----------: | :---------------------------------------------: |
  |  버블 정렬  |     O(n²)     |     O(n²)     |  비교와 교환  |               코딩이 가장 손쉬움                |
  | 카운팅 정렬 |    O(n+k)     |    O(n+k)     |  비교환 방식  |           n이 비교적 작을 때만 가능함           |
  |  선택 정렬  |     O(n²)     |     O(n²)     |  비교와 교환  |      교환의 회수가 버블, 삽입정렬보다 작음      |
  |   퀵 정렬   |   O(nlogn)    |     O(n²)     |   분할 정복   | 최악의 경우 O(n²)이지만, 평균적으로는 가장 빠름 |
  |  삽입 정렬  |     O(n²)     |     O(n²)     |  비교와 교환  |           n의 개수가 작을 때 효과적임           |
  |  병합 정렬  |   O(nlogn)    |   O(nlogn)    |   분할 정복   |      연결 리스트의 경우 가장 효율적인 방식      |

  

### 버블 정렬

- 버블 정렬(Bubble Sort)이란?

  > 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
  >
  > 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품모양 같아서 버블 정렬이라고 함

- 정렬 과정

  1. 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동함
  2. 한 단계가 끝나면 가장 큰 원소 또는 가장 작은 원소가 마지막 자리로 정렬됨

- 시간 복잡도 = O(n²)

<버블 정렬 슈도 코드>

```python
def BubbleSort(a): # 정렬할 List
  for i in ragne(len(a)-1, 0, -1): # 범위의 끝 위치
    for j in range(0, i):
      if a[j] > a[j+1]:
        a[j], a[j+1] = a[j+1], a[j]
```



### 카운팅 정렬

- 카운팅 정렬(Counting Sort)이란?

  > 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

- 정렬 과정

  1. 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스되는 카운트들의 리스트를 사용함 => 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능함
  2. 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함

- 시간 복잡도 = O(n + k): n은 리스트의 개수, k는 정수의 최대값

<카운팅 정렬 슈도 코드>

```python
def CountingSort(A, B, k):
  # A[1 .. n] -- 입력 리스트 사용된 숫자(1 ~ k)
  # B[1 .. n] -- 정렬된 리스트
  # C[1 .. k] -- 카운트 리스트
  
  C = [0]*k
  
  for i in range(0, len(B)):
    C[A[i]] += 1
    
  for i in range(1, len(C)):
    C[i] += C[i-1]
    
  for i in range(len(B)-1, -1, -1):
    B[C[A[i]-1]] = A[i]
    C[A[i]] -= 1
```

```python
a = [0, 4, 1, 3, 1, 2, 4, 1]
b = [0] * len(a)
CountingSort(a, b, 5)
print(b)
```



### 셀렉션 알고리즘

- 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법
- 최소값, 최대값 혹은 중간값을 찾는 알고리즘을 의미하기도 함

<셀렉션 선택 과정>

1. **정렬 알고리즘**을 이용하여 자료를 정렬함
2. 원하는 순서에 있는 **원소 가져오기**

> e.g.) k번째로 작은 원소를 찾는 알고리즘
>
> - 1번부터 k번째까지 작은 원소들을 찾아 List의 앞쪽으로 이동시키고, List의 k번째를 반환함
> - k가 비교적 작을 때 유용하며 O(kn)의 수행시간을 필요로 함
>
> ```python
> def selection(list, k):
>   for i in range(0, k):
>     minIndex = i
>     for j in range(i+1, len(list)):
>       if list[minIndex] > list[j]:
>         minIndex = j
>     list[i], list[minIndex] = list[minIndex], list[i]
>   return list[k-1]
> ```



### 선택 정렬

- 셀렉션 알고리즘을 이용한 정렬 방식; 셀렉션 알고리즘을 전체 자료에 적용한 것
- 주어진 자료들 중 **가장 작은 값의 원소부터 차례대로** 선택하여 위치를 교환하는 방식
- 시간 복잡도: O(n²)

<정렬과정>

1. 주어진 List에서 **최소값을 찾음**
2. 그 값을 List의 맨 앞에 위치한 값과 교환함
3. 맨 처음 위치를 제외한 나머지 List를 대상으로 위의 과정을 반복함

<선택 정렬 슈도코드>

```python
def selectionSort(a):
  for i in range(0, len(a)-1):
    min = i
    for j in range(i+1, len(a)):
      if a[min] > a[j]:
        min = j
    a[i], a[min] = a[min], a[i]
```



### 퀵 정렬

- 퀵 정렬과 합병 정렬의 비교

  - 공통점

  주어진 리스트를 두 개로 분할하고, 각각을 정렬함

  - 차이점

  |                          합병 정렬                          |                           퀵 정렬                            |
  | :---------------------------------------------------------: | :----------------------------------------------------------: |
  |            분할할 때, 단순하게 두 부분으로 나눔             | 분할할 때, 기준 아이템(Pivot Item)을 중심으로, 이보다 **작은 것은 왼편, 큰 것은 오른편**에 위치시킴 |
  | 각 부분 정렬이 끝난 후, **'합병'이란 후처리 작업이 필요함** |   각 부분 정렬이 끝난 후, **후처리 작업이 필요하지 않음**    |

  평균 시간 복잡도: O(nlogn)

  최악의 시간 복잡도는 O(n²) -> 합병정렬에 비해 좋지 못함

  

  <퀵 정렬 슈도 코드>

   ```python
  def quickSort(a, begin, end):
    if begin < end:
      p = partition(a, begin, end)
      quickSort(a, begin, p-1)
      quickSort(a, p+1, end)
   ```

  <주어진 리스트에서 피봇을 구하는 알고리즘>

  ```python
  def partition(a, begin, end):
    pivot = (begin + end) // 2
    L = begin
    R = end
    while L < R:
      while a[L] < a[pivot] and L < R:
        L += 1
      while a[R] >= a[pivot] and L < R:
        R -= 1
      if L < R:
        if L == pivot:
          pivot = R
          a[L], a[R] = a[R], a[L]
    a[pivot], a[R] = a[R], a[pivot]
    return R
  ```

  

  







